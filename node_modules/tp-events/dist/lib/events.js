'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
var const_1 = require("./lib/const");
var utils_1 = require("./lib/utils");
/**
 */
var EventEmitter = /** @class */ (function () {
    function EventEmitter() {
        this._events = {};
        this._maxListeners = const_1.DEFAULT_MAX_LISTENER;
        this.defaultMaxListeners = const_1.DEFAULT_MAX_LISTENER;
    }
    // /**
    //  * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
    //  * @return {Function} Non conflicting EventEmitter class.
    //  * TODO
    //  */
    // static noConflict(): Function {
    //   return EventEmitter
    // }
    // get _eventsCount() {
    //   return this.eventNames().length
    // }
    /**
     * Returns the current max listener value for the EventEmitter
     * which is either set by emitter.setMaxListeners(n) or defaults
     * to EventEmitter.defaultMaxListeners.
     * @return {number}
     */
    EventEmitter.prototype.getMaxListeners = function () {
        return this._maxListeners;
    };
    /**
     * By default EventEmitters will print a warning if more than 10
     * listeners are added for a particular event. This is a useful
     * default that helps finding memory leaks. Obviously, not all
     * events should be limited to just 10 listeners.
     * The emitter.setMaxListeners() method allows the limit to be
     * modified for this specific EventEmitter instance. The value
     * can be set to Infinity (or 0) to indicate an unlimited
     * number of listeners.
     * @param {number} maxListeners - The number of max listeners.
     * @return {EventEmitter}
     */
    EventEmitter.prototype.setMaxListeners = function (maxListeners) {
        if (!utils_1.isPositiveNumber(maxListeners)) {
            throw new TypeError('[events] MaxListeners number must be a positive number!');
        }
        this._maxListeners = maxListeners;
        return this;
    };
    /**
     * Returns an array listing the events for which the emitter
     * has registered listeners. The values in the array will be
     * strings or Symbols.
     * @param {EventName} eventName - The name of the event.
     * @param {any[]} [...args] - arguments pass to event listener.
     * @return {boolean} Returns true if the event had listeners, false otherwise.
     */
    EventEmitter.prototype.emit = function (eventName) {
        var _this = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var _events = this._getEvents();
        if (_events.hasOwnProperty(eventName)) {
            var listeners = _events[eventName].concat();
            var hasListeners = listeners.length > 0;
            listeners.forEach(function (listenerFunction) { return listenerFunction.apply(_this, args); });
            return hasListeners;
        }
        return false;
    };
    /**
     * Returns an array listing the events for which the emitter
     * has registered listeners. The values in the array will be
     * strings or Symbols.
     * @return {EventName[]}
     */
    EventEmitter.prototype.eventNames = function () {
        var _events = this._getEvents();
        return Object.keys(_events) || [];
    };
    /**
     * Returns the number of listeners listening to the event named eventName.
     * @param {EventName} eventName - The name of the event.
     * @return {number}
     */
    EventEmitter.prototype.listenerCount = function (eventName) {
        var _events = this._getEvents();
        if (_events.hasOwnProperty(eventName) && utils_1.isArray(_events[eventName])) {
            return _events[eventName].length;
        }
        return 0;
    };
    /**
     * Returns a copy of the array of listeners for the event named eventName.
     * @param {EventName} eventName - The name of the event.
     * @return {Function[]}
     */
    EventEmitter.prototype.listeners = function (eventName) {
        var _events = this._getEvents();
        var _listeners = [];
        if (_events.hasOwnProperty(eventName)) {
            var _rawListeners = _events[eventName];
            _rawListeners.forEach(function (item) {
                _listeners.push(item.listener);
            });
        }
        return _listeners;
    };
    /**
     * Returns a copy of the array of listeners for the event named eventName.
     * @param {EventName} eventName - The name of the event.
     * @param {Function} listener - The callback function
     * @return {EventEmitter}
     */
    EventEmitter.prototype.addListener = function (eventName, listener) {
        return this._addListener(eventName, listener, false, false);
    };
    /**
     * Returns a copy of the array of listeners for the event named eventName.
     * @param {EventName} eventName - The name of the event.
     * @param {Function} listener - The callback function
     * @return {EventEmitter}
     */
    EventEmitter.prototype.on = function (eventName, listener) {
        return this._addListener(eventName, listener, false, false);
    };
    /**
     * Adds a one-time listener function for the event named eventName.
     * The next time eventName is triggered, this listener is removed
     * and then invoked.
     * @param {EventName} eventName - The name of the event.
     * @param {Function} listener - The callback function
     * @return {EventEmitter}
     */
    EventEmitter.prototype.once = function (eventName, listener) {
        return this._addListener(eventName, listener, true, false);
    };
    /**
     * Adds the listener function to the beginning of the listeners array
     * for the event named eventName. No checks are made to see if the
     * listener has already been added. Multiple calls passing the same
     * combination of eventName and listener will result in the listener
     * being added, and called, multiple times.
     * @param {EventName} eventName - The name of the event.
     * @param {Function} listener - The callback function
     * @return {EventEmitter}
     *
     * @example
     * server.prependListener('connection', (stream) => {
     *      console.log('someone connected!');
     * });
     */
    EventEmitter.prototype.prependListener = function (eventName, listener) {
        return this._addListener(eventName, listener, false, true);
    };
    /**
     * Adds a one-time listener function for the event named eventName to the
     * beginning of the listeners array. The next time eventName is triggered,
     * this listener is removed, and then invoked.
     * @param {EventName} eventName - The name of the event.
     * @param {Function} listener - The callback function
     * @return {EventEmitter}
     */
    EventEmitter.prototype.prependOnceListener = function (eventName, listener) {
        return this._addListener(eventName, listener, true, true);
    };
    /**
     * Removes all listeners, or those of the specified eventName.
     * @param {EventName[]} eventNames - The names array of the event.
     * @return {EventEmitter}
     */
    EventEmitter.prototype.removeAllListeners = function (eventNames) {
        var _events = this._getEvents();
        if (eventNames && utils_1.isArray(eventNames) && eventNames.length > 0) {
            // remove the specified eventName list
            var i = 0;
            var len = eventNames.length;
            for (; len > i; i++) {
                var _eventName = eventNames[i];
                if (_events.hasOwnProperty(_eventName)) {
                    delete _events[_eventName];
                }
            }
        }
        else {
            // remove all
            this._events = {};
        }
        // The 'removeListener' event is emitted after the listener is removed.
        this.emit(const_1.REMOVE_LISTENER);
        return this;
    };
    /**
     * Removes all listeners, or those of the specified eventName.
     * @param {EventName} eventName - The name of the event.
     * @param {Function} listener - The callback function
     * @return {EventEmitter}
     */
    EventEmitter.prototype.removeListener = function (eventName, listener) {
        return this._removeListener(eventName, listener);
    };
    /**
     * Removes all listeners, or those of the specified eventName.
     * @param {EventName} eventName - The name of the event.
     * @param {Function} listener - The callback function
     * @return {EventEmitter}
     */
    EventEmitter.prototype.off = function (eventName, listener) {
        return this._removeListener(eventName, listener);
    };
    /**
     * Returns a copy of the array of listeners for the event named
     * eventName, including any wrappers (such as those created by .once).
     * @param {EventName} eventName - The name of the event.
     * @return {ListenerFunction[]}
     */
    EventEmitter.prototype.rawListeners = function (eventName) {
        var _events = this._getEvents();
        var _rawListeners = [];
        if (_events.hasOwnProperty(eventName)) {
            _rawListeners = _events[eventName].concat();
        }
        return _rawListeners;
    };
    /**
     * 检查当前事件名是否超过设定的最大监听数
     * @param {EventName} eventName - The name of the event.
     * @return {boolean}
     * @private
     */
    EventEmitter.prototype._checkIfMatchMaxListener = function (eventName) {
        if (this._maxListeners === undefined || this._maxListeners === 0)
            return false;
        var _events = this._getEvents();
        var _res = false;
        if (_events.hasOwnProperty(eventName) && utils_1.isArray(_events[eventName])) {
            var length_1 = _events[eventName].length;
            _res = length_1 > this._maxListeners;
            if (_res) {
                /* istanbul ignore next */
                throw new RangeError("\n        [events] The current event " + eventName + "(" + length_1 + ") has exceeded the maximum \n        number of listeners(" + this._maxListeners + "), You need to be aware of the  \n        existence of possible EventEmitter memory leak!\n        ");
            }
        }
        return _res;
    };
    /**
     * Removes all listeners, or those of the specified eventName.
     * @param {EventName} eventName - The name of the event.
     * @param {Function} listener - The callback function
     * @return {EventEmitter}
     */
    EventEmitter.prototype._removeListener = function (eventName, listener) {
        var _events = this._getEvents();
        if (!_events.hasOwnProperty(eventName))
            return this;
        var listeners = _events[eventName];
        if (utils_1.isArray(listeners) && listeners.length > 0) {
            var index = utils_1.indexOfListener(listeners, listener);
            if (index !== -1) {
                listeners.splice(index, 1);
            }
        }
        if (!utils_1.isArray(listeners) || listeners.length === 0) {
            delete _events[eventName];
        }
        // The 'removeListener' event is emitted after the listener is removed.
        this.emit(const_1.REMOVE_LISTENER);
        return this;
    };
    /**
     * 添加监听
     * @param {EventName} eventName - The name of the event.
     * @param {Function} listener - The callback function
     * @param {Boolean} [once=false] - once or not
     * @param {Boolean} [prepend=false] - prepend or not
     * @return {EventEmitter}
     * @private
     */
    EventEmitter.prototype._addListener = function (eventName, listener, once, prepend) {
        if (once === void 0) { once = false; }
        if (prepend === void 0) { prepend = false; }
        if (!utils_1.isValidEventName(eventName) || !utils_1.isValidListener(listener)) {
            /* istanbul ignore next */
            throw new TypeError("[events] Invalid arguments of 'eventName' or 'listener'!");
        }
        var _events = this._getEvents();
        if (!_events.hasOwnProperty(eventName)) {
            _events[eventName] = [];
        }
        if (!utils_1.isArray(_events[eventName])) {
            /* istanbul ignore next */
            throw new TypeError('[events] The events[eventName] must be array type!');
        }
        var prependMethod = prepend ? 'unshift' : 'push';
        // emit "NEW_LISTENER" before added
        if (const_1.NEW_LISTENER !== eventName) {
            this.emit(const_1.NEW_LISTENER, eventName, listener);
        }
        _events[eventName][prependMethod](utils_1.createListenerFunction(this, eventName, listener, once));
        this._checkIfMatchMaxListener(eventName);
        return this;
    };
    /**
     * Fetches the events object and creates one if required.
     *
     * @return {Events} The events storage object.
     */
    EventEmitter.prototype._getEvents = function () {
        return this._events || (this._events = {});
    };
    return EventEmitter;
}());
exports.default = EventEmitter;
//# sourceMappingURL=events.js.map