// The EventEmitter instance will emit its own 'newListener'
// event before a listener is added to its internal array of
// listeners.
var NEW_LISTENER = 'newListener';
// The 'removeListener' event is emitted after the listener
// is removed.
var REMOVE_LISTENER = 'removeListener';
// a maximum of 10 listeners can be registered for any single event
var DEFAULT_MAX_LISTENER = 10;

function isValidListener(listener) {
    var isValid = isFunction(listener);
    if (!isValid) {
        throw new TypeError("[events] the type of 'listener' is not valid");
    }
    return isValid;
}
function isValidEventName(eventName) {
    var isValid = isString(eventName) || isSymbol(eventName);
    if (!isValid) {
        throw new TypeError("[events] the type of 'eventName' is not valid");
    }
    return isValid;
}
function isString(val) {
    return typeof val === 'string';
}
function isSymbol(val) {
    return typeof val === 'symbol';
}
function isFunction(val) {
    return typeof val === 'function';
}
function isPositiveNumber(val) {
    return typeof val === 'number' && val >= 0;
}
var isArray = Array.isArray;
/**
 * Finds the index of the listener for the event in its storage array.
 *
 * @param {Function[]} listeners Array of listeners to search through.
 * @param {Function} listener Method to look for.
 * @return {Number} Index of the specified listener, -1 if not found
 * @api private
 */
function indexOfListener(listeners, listener) {
    var i = listeners.length;
    while (i--) {
        if (listeners[i] && listeners[i].listener === listener) {
            return i;
        }
    }
    return -1;
}
function createListenerFunction(events, eventName, listener, once) {
    if (once === void 0) { once = false; }
    var listenerFunction = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (once) {
            events.removeListener(eventName, listener);
        }
        listener.apply(events, args);
    };
    listenerFunction.listener = listener;
    listenerFunction.once = once;
    return listenerFunction;
}

/**
 */
var EventEmitter = /** @class */ (function () {
    function EventEmitter() {
        this._events = {};
        this._maxListeners = DEFAULT_MAX_LISTENER;
        this.defaultMaxListeners = DEFAULT_MAX_LISTENER;
    }
    // /**
    //  * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
    //  * @return {Function} Non conflicting EventEmitter class.
    //  * TODO
    //  */
    // static noConflict(): Function {
    //   return EventEmitter
    // }
    // get _eventsCount() {
    //   return this.eventNames().length
    // }
    /**
     * Returns the current max listener value for the EventEmitter
     * which is either set by emitter.setMaxListeners(n) or defaults
     * to EventEmitter.defaultMaxListeners.
     * @return {number}
     */
    EventEmitter.prototype.getMaxListeners = function () {
        return this._maxListeners;
    };
    /**
     * By default EventEmitters will print a warning if more than 10
     * listeners are added for a particular event. This is a useful
     * default that helps finding memory leaks. Obviously, not all
     * events should be limited to just 10 listeners.
     * The emitter.setMaxListeners() method allows the limit to be
     * modified for this specific EventEmitter instance. The value
     * can be set to Infinity (or 0) to indicate an unlimited
     * number of listeners.
     * @param {number} maxListeners - The number of max listeners.
     * @return {EventEmitter}
     */
    EventEmitter.prototype.setMaxListeners = function (maxListeners) {
        if (!isPositiveNumber(maxListeners)) {
            throw new TypeError('[events] MaxListeners number must be a positive number!');
        }
        this._maxListeners = maxListeners;
        return this;
    };
    /**
     * Returns an array listing the events for which the emitter
     * has registered listeners. The values in the array will be
     * strings or Symbols.
     * @param {EventName} eventName - The name of the event.
     * @param {any[]} [...args] - arguments pass to event listener.
     * @return {boolean} Returns true if the event had listeners, false otherwise.
     */
    EventEmitter.prototype.emit = function (eventName) {
        var _this = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var _events = this._getEvents();
        if (_events.hasOwnProperty(eventName)) {
            var listeners = _events[eventName].concat();
            var hasListeners = listeners.length > 0;
            listeners.forEach(function (listenerFunction) { return listenerFunction.apply(_this, args); });
            return hasListeners;
        }
        return false;
    };
    /**
     * Returns an array listing the events for which the emitter
     * has registered listeners. The values in the array will be
     * strings or Symbols.
     * @return {EventName[]}
     */
    EventEmitter.prototype.eventNames = function () {
        var _events = this._getEvents();
        return Object.keys(_events) || [];
    };
    /**
     * Returns the number of listeners listening to the event named eventName.
     * @param {EventName} eventName - The name of the event.
     * @return {number}
     */
    EventEmitter.prototype.listenerCount = function (eventName) {
        var _events = this._getEvents();
        if (_events.hasOwnProperty(eventName) && isArray(_events[eventName])) {
            return _events[eventName].length;
        }
        return 0;
    };
    /**
     * Returns a copy of the array of listeners for the event named eventName.
     * @param {EventName} eventName - The name of the event.
     * @return {Function[]}
     */
    EventEmitter.prototype.listeners = function (eventName) {
        var _events = this._getEvents();
        var _listeners = [];
        if (_events.hasOwnProperty(eventName)) {
            var _rawListeners = _events[eventName];
            _rawListeners.forEach(function (item) {
                _listeners.push(item.listener);
            });
        }
        return _listeners;
    };
    /**
     * Returns a copy of the array of listeners for the event named eventName.
     * @param {EventName} eventName - The name of the event.
     * @param {Function} listener - The callback function
     * @return {EventEmitter}
     */
    EventEmitter.prototype.addListener = function (eventName, listener) {
        return this._addListener(eventName, listener, false, false);
    };
    /**
     * Returns a copy of the array of listeners for the event named eventName.
     * @param {EventName} eventName - The name of the event.
     * @param {Function} listener - The callback function
     * @return {EventEmitter}
     */
    EventEmitter.prototype.on = function (eventName, listener) {
        return this._addListener(eventName, listener, false, false);
    };
    /**
     * Adds a one-time listener function for the event named eventName.
     * The next time eventName is triggered, this listener is removed
     * and then invoked.
     * @param {EventName} eventName - The name of the event.
     * @param {Function} listener - The callback function
     * @return {EventEmitter}
     */
    EventEmitter.prototype.once = function (eventName, listener) {
        return this._addListener(eventName, listener, true, false);
    };
    /**
     * Adds the listener function to the beginning of the listeners array
     * for the event named eventName. No checks are made to see if the
     * listener has already been added. Multiple calls passing the same
     * combination of eventName and listener will result in the listener
     * being added, and called, multiple times.
     * @param {EventName} eventName - The name of the event.
     * @param {Function} listener - The callback function
     * @return {EventEmitter}
     *
     * @example
     * server.prependListener('connection', (stream) => {
     *      console.log('someone connected!');
     * });
     */
    EventEmitter.prototype.prependListener = function (eventName, listener) {
        return this._addListener(eventName, listener, false, true);
    };
    /**
     * Adds a one-time listener function for the event named eventName to the
     * beginning of the listeners array. The next time eventName is triggered,
     * this listener is removed, and then invoked.
     * @param {EventName} eventName - The name of the event.
     * @param {Function} listener - The callback function
     * @return {EventEmitter}
     */
    EventEmitter.prototype.prependOnceListener = function (eventName, listener) {
        return this._addListener(eventName, listener, true, true);
    };
    /**
     * Removes all listeners, or those of the specified eventName.
     * @param {EventName[]} eventNames - The names array of the event.
     * @return {EventEmitter}
     */
    EventEmitter.prototype.removeAllListeners = function (eventNames) {
        var _events = this._getEvents();
        if (eventNames && isArray(eventNames) && eventNames.length > 0) {
            // remove the specified eventName list
            var i = 0;
            var len = eventNames.length;
            for (; len > i; i++) {
                var _eventName = eventNames[i];
                if (_events.hasOwnProperty(_eventName)) {
                    delete _events[_eventName];
                }
            }
        }
        else {
            // remove all
            this._events = {};
        }
        // The 'removeListener' event is emitted after the listener is removed.
        this.emit(REMOVE_LISTENER);
        return this;
    };
    /**
     * Removes all listeners, or those of the specified eventName.
     * @param {EventName} eventName - The name of the event.
     * @param {Function} listener - The callback function
     * @return {EventEmitter}
     */
    EventEmitter.prototype.removeListener = function (eventName, listener) {
        return this._removeListener(eventName, listener);
    };
    /**
     * Removes all listeners, or those of the specified eventName.
     * @param {EventName} eventName - The name of the event.
     * @param {Function} listener - The callback function
     * @return {EventEmitter}
     */
    EventEmitter.prototype.off = function (eventName, listener) {
        return this._removeListener(eventName, listener);
    };
    /**
     * Returns a copy of the array of listeners for the event named
     * eventName, including any wrappers (such as those created by .once).
     * @param {EventName} eventName - The name of the event.
     * @return {ListenerFunction[]}
     */
    EventEmitter.prototype.rawListeners = function (eventName) {
        var _events = this._getEvents();
        var _rawListeners = [];
        if (_events.hasOwnProperty(eventName)) {
            _rawListeners = _events[eventName].concat();
        }
        return _rawListeners;
    };
    /**
     * 检查当前事件名是否超过设定的最大监听数
     * @param {EventName} eventName - The name of the event.
     * @return {boolean}
     * @private
     */
    EventEmitter.prototype._checkIfMatchMaxListener = function (eventName) {
        if (this._maxListeners === undefined || this._maxListeners === 0)
            return false;
        var _events = this._getEvents();
        var _res = false;
        if (_events.hasOwnProperty(eventName) && isArray(_events[eventName])) {
            var length_1 = _events[eventName].length;
            _res = length_1 > this._maxListeners;
            if (_res) {
                /* istanbul ignore next */
                throw new RangeError("\n        [events] The current event " + eventName + "(" + length_1 + ") has exceeded the maximum \n        number of listeners(" + this._maxListeners + "), You need to be aware of the  \n        existence of possible EventEmitter memory leak!\n        ");
            }
        }
        return _res;
    };
    /**
     * Removes all listeners, or those of the specified eventName.
     * @param {EventName} eventName - The name of the event.
     * @param {Function} listener - The callback function
     * @return {EventEmitter}
     */
    EventEmitter.prototype._removeListener = function (eventName, listener) {
        var _events = this._getEvents();
        if (!_events.hasOwnProperty(eventName))
            return this;
        var listeners = _events[eventName];
        if (isArray(listeners) && listeners.length > 0) {
            var index = indexOfListener(listeners, listener);
            if (index !== -1) {
                listeners.splice(index, 1);
            }
        }
        if (!isArray(listeners) || listeners.length === 0) {
            delete _events[eventName];
        }
        // The 'removeListener' event is emitted after the listener is removed.
        this.emit(REMOVE_LISTENER);
        return this;
    };
    /**
     * 添加监听
     * @param {EventName} eventName - The name of the event.
     * @param {Function} listener - The callback function
     * @param {Boolean} [once=false] - once or not
     * @param {Boolean} [prepend=false] - prepend or not
     * @return {EventEmitter}
     * @private
     */
    EventEmitter.prototype._addListener = function (eventName, listener, once, prepend) {
        if (once === void 0) { once = false; }
        if (prepend === void 0) { prepend = false; }
        if (!isValidEventName(eventName) || !isValidListener(listener)) {
            /* istanbul ignore next */
            throw new TypeError("[events] Invalid arguments of 'eventName' or 'listener'!");
        }
        var _events = this._getEvents();
        if (!_events.hasOwnProperty(eventName)) {
            _events[eventName] = [];
        }
        if (!isArray(_events[eventName])) {
            /* istanbul ignore next */
            throw new TypeError('[events] The events[eventName] must be array type!');
        }
        var prependMethod = prepend ? 'unshift' : 'push';
        // emit "NEW_LISTENER" before added
        if (NEW_LISTENER !== eventName) {
            this.emit(NEW_LISTENER, eventName, listener);
        }
        _events[eventName][prependMethod](createListenerFunction(this, eventName, listener, once));
        this._checkIfMatchMaxListener(eventName);
        return this;
    };
    /**
     * Fetches the events object and creates one if required.
     *
     * @return {Events} The events storage object.
     */
    EventEmitter.prototype._getEvents = function () {
        return this._events || (this._events = {});
    };
    return EventEmitter;
}());

export default EventEmitter;
//# sourceMappingURL=events.es5.js.map
